abstract symmetry {
    has_many sym portions;
}

/* TODO: For humans a coronal plane is vertical and a transverse plane is horizontal, but for (embryos and) quadrupeds a coronal plane is horizontal and a transverse plane is vertical. */

/* sagittal or median plane (Y-Z), also superior-inferior */
abstract symmetry median {
    portions left right;
}

/* coronal or frontal plane (Y-X), also ventral-dorsal */
abstract symmetry frontal {
    portions anterior posterior;
}

/* transverse or horizonal plane (X-Z), also cranial-caudal */
abstract symmetry axial {
    portions upper lower;
}

abstract object,effect_target composition {
    has_many sym container_classes;
    has_many optional sym mutable_container_classes;
    has_many optional sym added_value_container_classes;

    has_many optional map symmetric {
        int count;
        sym container_class;
        sym object_type;
        many sym symmetries;
    }

    has_many optional map morphic {
        int count;
        sym container_class;
        sym object_type;
        many sym symmetries;

        many sym morphism_classes;
    }

    uses composition;

    /* The classic composition. */
    /* Internals are the things inside, e.g. a backpack or a stomach.
       Incidentals are what the thing is made of, e.g. the cloth the backpack is made out of.
       Externals are things attached to the outside, from paint to a glued-on moose to an article of clothing.
    */
    container_classes             internal incidental external;
    /* Determines which components are modifiable after creation */
    mutable_container_classes                         external;
    /* Determines whether the value of the contained item is added to the container */
    added_value_container_classes          incidental external;

    has_many optional sym internal;
    has_many optional sym incidental;
    has_many optional sym external;
}

abstract composition made {
    class_many map recipes {
        sym technique;
        many sym components;
        int duplicates;
    }

    has sym quality;
    uses made;
}

post_process {
    Log.debug("Propagating components information for made objects", 6)
    instantiable_types_of(:made).each do |made|
        recipes = info_for(made, :recipes)
        if recipes.nil? || recipes.empty?
            Log.error("No recipes found for #{made.inspect}")
            next
        end

        recipes.each do |recipe|
            components = recipe[:components]
            if components.nil? || components.empty?
                Log.error("No components found for recipe #{recipe}")
                next
            end
            components.each do |component|
                unless has_type?(component)
                    # identical to the raw_info_for exception, but in the post_process block to avoid the binding line-mashed stack dump.
                    Log.error("#{component.inspect} not defined as db type")
                    next
                end
                types_of(component) do |subtype|
                    if has_type?(subtype)
                        Log.debug("#{subtype} is used in #{made}", 6)
                        name = :used_in
                        # This is going to become a performance issue later
                        modify_info(subtype, name, []) << made
                        modify_info(subtype, name).uniq!
                    else
                        Log.error("#{subtype.inspect} not defined as db type")
                    end
                end
            end
        end
    end
}
