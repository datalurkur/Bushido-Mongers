abstract symmetry_type {
    has_many string primary_directions;
    has_many optional string secondary_directions;
    has_many optional string tertiary_directions;
}

abstract symmetry_type balanced_axial {
    primary_directions left right;
    secondary_directions front rear;
    tertiary_directions interior anterior;
}

abstract object composition {
    has_many sym container_classes;
    has_many optional sym mutable_container_classes;
    has_many optional sym added_value_container_classes;

    has_many optional map symmetric {
        int count;
        sym container_class;
        sym object_type;
        sym symmetry_type;
    }

    uses composition;

    /* The classic composition. */
    /* Internals are the things inside, e.g. a backpack or a stomach.
       Incidentals are what the thing is made of, e.g. the cloth the backpack is made out of.
       Externals are things attached to the outside, from paint to a glued-on moose to an article of clothing.
    */
    container_classes             internal incidental external;
    /* Determines which components are modifiable after creation */
    mutable_container_classes                         external;
    /* Determines whether the value of the contained item is added to the container */
    added_value_container_classes          incidental external;

    has_many optional sym internal;
    has_many optional sym incidental;
    has_many optional sym external;
}

abstract composition constructed {
    class_many map recipes {
        sym technique;
        many sym components;
        int duplicates;
        string called;
    }

    has sym quality;
    uses constructed;
}

post_process {
    Log.debug("Propagating component information for constructed objects", 6)
    instantiable_types_of(:constructed).each do |constructed|
        recipes = info_for(constructed, :recipes)
        if recipes.nil? || recipes.empty?
            Log.error("No recipes found for #{constructed.inspect}")
            next
        end

        recipes.each do |recipe|
            components = recipe[:components]
            if components.nil? || components.empty?
                Log.error("No components found for recipe #{recipe}")
                next
            end
            components.each do |component|
                unless has_type?(component)
                    # identical to the raw_info_for exception, but in the post_process block to avoid the binding line-mashed stack dump.
                    Log.error("#{component.inspect} not defined as db type")
                    next
                end
                types_of(component) do |subtype|
                    if has_type?(subtype)
                        Log.debug("#{subtype} is used in #{constructed}", 6)
                        name = :used_in
                        # This is going to become a performance issue later
                        modify_info(subtype, name, []) << constructed
                        modify_info(subtype, name).uniq!
                    else
                        Log.error("#{subtype.inspect} not defined as db type")
                    end
                end
            end
        end
    end
}
