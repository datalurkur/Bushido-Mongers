abstract root symmetry_type {
    has_many string primary_directions;
    has_many optional string secondary_directions;
    has_many optional string tertiary_directions;
}

symmetry_type balanced_axial {
    primary_directions left right;
    secondary_directions front rear;
    tertiary_directions interior anterior;
}

abstract root composition_root {
    has_many sym container_classes;
    has_many optional sym mutable_container_classes;
    has_many optional sym preserved_container_classes;
    has_many optional sym added_value_container_classes;

    has_many optional map symmetric {
        int count;
        sym container_class;
        sym object_type;
        sym symmetry_type;
    }

    uses composition;
}

/* The classic composition. */
abstract composition_root composition {
    container_classes             internal incidental external;
    /* Determines which components are modifiable after creation */
    mutable_container_classes                         external;
    /* Determines which components are destroyed if this item is destroyed */
    preserved_container_classes                       external;
    /* Determines whether the value of the contained item is added to the container */
    added_value_container_classes          incidental external;

    has_many optional sym internal;
    has_many optional sym incidental;
    has_many optional sym external;
}

abstract composition constructed {
    class_many map recipes {
        sym technique;
        many sym components;
        int duplicates;
        string called;
    }

    has sym quality;
    uses constructed;
}

post_process {
    Log.debug("Propagating component information for constructed objects", 1)
    types_of(:constructed, true).each do |constructed|
        recipes = info_for(constructed, :recipes)
        Log.error("No recipes found for #{constructed.inspect}") if recipes.empty?
        recipes.each do |recipe|
            components = recipe[:components]
            Log.error("No components found for recipe #{recipe}") if components.empty?
            components.each do |component|
                propagate_recursive(component) do |subtype|
                    Log.debug("#{subtype} is used in #{constructed}", 1)
                    name = :used_in
                    # This is going to become a performance issue later
                    modify_info(subtype, name, []) << constructed
                    modify_info(subtype, name).uniq!
                end
            end
        end
    end
}
