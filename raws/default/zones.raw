abstract root zone {
    /* How deep in the world hierarchy the zone can be created. */
    class_many int depth_range;
    depth_range 0;

    /* Acceptable sub-zones */
    class_many optional sym child_zones;

    has_many sym keywords;
/*    needs keywords; */

    class_many optional sym optional_keywords;

    /* Can spawn NPCs */
    class_many optional sym spawn_npcs;

    /* Can spawn items */
    class_many optional sym spawn_items;
    spawn_items rock;

    class sym sideness;
    sideness outside;

    at_creation {
        # TODO - Insert some of the optional_keywords here.
        keywords = self.keywords + (params[:inherited_keywords] || [])
        {
            :keywords => keywords
        }
    }
}

zone haven {
    depth_range 1 2 3;
    keywords peaceful;
    child_zones tavern inn;
    spawn_npcs peacekeeper merchant;
}

zone meadow {
    depth_range 0 1 2 3;
    keywords grassy;
    spawn_npcs monster;
}

abstract zone inside_zone {
    sideness inside;
}

abstract zone monster_spawner {
    spawn_npcs monster;
}

inside_zone,monster_spawner castle {
    depth_range 0 1 2 3 4;
    keywords constructed;
    child_zones barracks portcullis sewer tower dungeon;
}

inside_zone,monster_spawner barracks {
    depth_range 0 1;
    keywords constructed;
    child_zones sewer tower dungeon;
}

inside_zone,monster_spawner sewer {
    depth_range 0 1 2;
    keywords dank wet;
}

zone,monster_spawner dock {
    depth_range 1;
    keywords wooden;
    child_zones pier boat;
}

zone,monster_spawner boat {
    depth_range 0 1;
    keywords wet;
}

zone pier {}
zone jungle {}
zone forest {}
zone orchard {}
zone swamp {}
zone mountain {}
zone desert {}
zone tundra {}
zone portcullis {}
inside_zone tower {}
inside_zone dungeon {}
inside_zone tavern {}
inside_zone inn {}
inside_zone temple {}
/*
zone temple_that_serves_as_the_final_bastion_of_light_in_an_otherwise_evil_forest {
    depth_range 0 1;
    keywords shiny joke_zone;
}
*/

post_process {
    self.find_subtypes(:zone, {}, true).each do |zone|
        unless info_for(zone, :spawn_npcs).empty?
            list = info_for(zone, :spawn_npcs).dup
            info_for(zone, :spawn_npcs).clear
            info_for(zone, :spawn_npcs) << list.inject([]) { |arr, spawn_npcs| arr + types_of(spawn_npcs) }
            info_for(zone, :spawn_npcs).flatten!
        end
    end
    self.find_subtypes(:npc, {}, true).each do |npc|
        if spawns_in = info_for(npc, :spawns_in)
            spawns_in.each do |zone|
                info_for(zone, :spawn_npcs) << npc
                info_for(zone, :spawn_npcs).uniq!
            end
        end
    end
}
