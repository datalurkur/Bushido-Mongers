abstract item composition {
    has_many optional sym internal;
    has_many optional sym incidental;
    has_many optional sym external;

    /* Determines which components are destroyed if this item is destroyed */
    class bool preserve_internal;
    class bool preserve_incidental;
    class bool preserve_external;

    preserve_internal   false;
    preserve_incidental false;
    preserve_external   true;

    /* Determines whether objects can be placed inside this item */
    class bool is_container;
    is_container false;

    /* TODO - store particular types or number of items only */

    uses composition;
}

abstract composition constructed {
    class_many sym required_components;
    class sym technique;

    has sym quality;

    needs components quality;

    at_creation {
        # Remove component items from the world
        params[:components].each do |component|
            # This next is only necessary if the component has been created
            # ex nihilo, which happens sometimes.
            next if component.position.nil?
            component.position.remove_object(component)
        end

        # Created object quality depends on the quality of its components as well
        avg_component_quality = params[:components].inject(0.0) { |s,i|
            s + Quality.index(i.is_type?(:constructed) ? i.quality : :standard)
        } / params[:components].size
        quality = (Quality.index(params[:quality]) + avg_component_quality) / 2.0
        quality_level = Quality.levels[quality.ceil]

        {
            :quality    => quality_level,
            :incidental => params[:components]
        }
    }
}

post_process {
    Log.debug("Propagating component information for constructed objects", 7)
    types_of(:constructed, true).each do |constructed|
        info_for(constructed, :required_components).each do |component|
            propagate_recursive(component) do |subtype|
                Log.debug("#{subtype} is used in #{constructed}", 7)
                name = :used_in
                set_info(subtype, name, init_or_info(subtype, name, []) << constructed)
            end
        end
    end
}